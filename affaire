question a poser aou autre ou se le note ici 




shader vertex pour l'animation du nuage 
calcule de position 

 frag shader
shader  color tout court pour la couleur du nuage 

shader ligth pour l'interaction de la couleur du nuage avec la lumiere 
calcule de couleur + calcule d'interaction avec la lumiere 

noise / bruit de perlin 


vec4 gl_Position pour un vertex shader, et vec4 gl_FragColor pour un fragment shader.

	// vertex shader de tuto3GL
	#version 330
	 
	uniform vec3 positions[36];     // declare un uniform, un tableau de vec3
	uniform float time;             // declare un uniform, time de type float
	 
	const vec3 deplace= vec3(...);  // declare une constante
	 
	void main( )
	{
	    gl_Position= vec4( positions[gl_VertexID] + deplace * time / 1000.0, 1.0 );
	    // positions[gl_VertexID] est un vec3 + vec3 * float / float, ce qui donne bien un vec3
	    // et le vec3 est complete par une valeur pour etre affecte a un vec4
	}


code a essayer ( juste un,, shader de bleu turquoise )
void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 uv = fragCoord/iResolution.xy;
    fragColor = vec4(0 , 11, 120 , 1.0);
}

code a essayer avec une fonction  (just un shader vert degueulasse)

vec3 couleur(){
    return vec3(0 , 11, 0 );
  }

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 uv = fragCoord/iResolution.xy;
    fragColor = vec4( couleur() , 1.0);
}





vec3 couleur(float t){
    vec3 a = vec3(0.5 , 0.5 , 0.5);
    vec3 b= vec3(0.5,0.8,0.5);
    vec3 c= vec3(1.1, 1.1 , 1.1);
    vec3 d= vec3(0.886,0.875,0.655);
    //palette de couleur pour la formule
    vec3 result = a+ b*cos(6.4513*(c*t + d));
    return result;
  }

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // uv (resolution) ramener a une taille 1*1 (2d) , recentrer par -0.5 puis 
    vec2 uv = ((fragCoord/iResolution.xy) -0.5 )  ; 
    uv.x *= iResolution.x / iResolution.y;
    //sauvegarde de l'etat de uv 
    vec2 folie = uv;
    //preparation de la couleur final a 0,0,0,0
    vec3 couleur_final = vec3(0.0);
    //boucle pour alleger la boucle
    for (float i=0.0; i<4.0; i++){
        //fraction de l'Ã©cran en 8 parties puis centrage
        uv = fract(uv *2.0) -0.5 ;
        // + on est eloigne du centre plus la valeur de d est grande
         float d =length(uv) + exp(-length(folie)); 
        //choix de couleur a un instant T
        vec3 col = couleur(length(folie) + iTime*i);
        //boucle sur sin
        d=sin(d*8.0 + (iTime)*10.0)/8.0;
        //rend visible les valeurs negative de d (celle qui s'annule au centre)
        d=abs(d);
        //va fluidifier les couleurs
        d= pow(0.02 / d, 1.2);
        //va ajouter les 2 mouvements de couleurs
        couleur_final+=col*d;
    }
    fragColor= vec4(couleur_final,1.0);
    
}